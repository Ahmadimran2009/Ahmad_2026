---
layout: post
title: 2018 MCQ reflection & sprint 3 reflection and big accomplishment
description: click here
type: issues
comments: True
---

# Overall what I learned
- I was able to get a better understanding on how ot read code and what the code really does. I also explored and learned a whole bunch of different computer science terms.

- Things I could improve on is my overall vocabulary because throughout the exam I felt like that I was guessing what most of the words meant using context clues and not knowing their real and true definition, I also had trouble with the questions that told us what someone wanted to code and gave us some code and we had to figure out which one is correct. This startled me because most of the code looks really similar with only slight differences making me second guess myself.

- During this whole MCQ I learned important terms such as the importance of citizen science, Internet Engineering Task Force (IETF), and cloud computing software.

# corrections 

Link to google doc- <a href="https://docs.google.com/document/d/158WVUX8bX5F-ZCwfzXu64uAM4HjQ9bloLy5YU9s3msc/edit?usp=sharing">link text</a>

# Analysis

![alt text]({{site.baseurl}}/images/mcqnumber1.png)
![alt text]({{site.baseurl}}/images/mcpnumber2.png)
![alt text]({{site.baseurl}}/images/mcqnumber3.png)

I accelled at 2.3: Extracting Information from Data, 3.1: Variables and Assignments, 2.2: Data Compression, 3.18: Undecidable Problems, 4.2: Fault Tolerance, 5.2: Digital Divide, and 5.5: Legal and Ethical Concerns. I did decent on 2.1: Binary Numbers, 3.6: Conditionals, 3.9: Developing Algorithms, 3.15: Random Values, 3.16: Simulations and 5.6: Safe Computing as you can see in the images above.

Weaknesses:

I did not do very well on 1.3: Program Design and Development, 2.4: Using Programs with Data, 3.3: Mathematical Expressions, 3.8: Iteration, 3.10: Lists, 3.13: Developing Procedures, 3.17: Algorithmic Efficiency, 5.4: Crowdsourcing, 1.4: Identifying and Correcting Errors, 3.5: Boolean Expressions, 4.1: The Internet, 5.1: Beneficial and Harmful Effects, 3.12: Calling Procedures

for 1.3 I now understand that incrementally adding code segments to correct, working programs can help programmers identify new errors that are introduced.

for 2.4 I know understand how various programs work for example

 A programmer is developing a word game. The programmer wants to create an algorithm that will take a list of words and return a list containing the first letter of all words that are palindromes (words that read the same backward or forward). The returned list should be in alphabetical order. For example, if the list contains the words Open bracket, open quotation, banana, close quotation, open quotation, kayak, close quotation, open quotation, mom, close quotation, open quotation, apple, close quotation, open quotation, level, close quotation, close bracket, the returned list would contain Open bracket, open quotation, k, close quotation, open quotation, l, close quotation, open quotation, m, close quotation, close bracket(because Open quotation, kayak, close quotation, Open quotation, level, close quotation, and Open quotation, mom, close quotationare palindromes).

The programmer knows that the following steps are necessary for the algorithm but is not sure in which order they should be executed.

A table is shown with 2 columns and 4 rows. The first row of the table contains the column headers, from left to right, Step and Explanation. The table is as follows: Shorten, Takes a list of words and returns a new list that contains only the first letter of each word from the input list Keep palindromes, Takes a list of words and returns a list that contains only the palindromes from the input list Sort, Takes a list of words and returns a copy of the list in alphabetical order

Executing which of the following sequences of steps will enable the algorithm to work as intended?

I. First shorten, then keep palindromes, then sort

II. First keep palindromes, then shorten, then sort

III. First sort, then keep palindromes, then shorten

Responses
A
I only
B
II only
C
I and III
D
II and III
Answer D
This option is correct. Options II and III perform the steps in a correct order. In order to generate the desired list, the algorithm must perform the "shorten" step after the "keep palindromes" step, otherwise the "keep palindromes" step would not be able to determine whether the original word was a palindrome.

for 3.3 Mathematical expressions I made a dumb mistake on counting but I now understand how integers in code works.

for 3.8 I made another dumb mistake because in the code I did not see the code starts from one which means that it only counts odd numbers meaning it doesnt count 20 and goes up to 19. Next time I will be more aware and analyze the code further and to the best of my ability

for 3.10 I now understand that Lists are an ordered collection of data or items, which can be different types (although they usually aren't). Lists are adaptable – they can contain duplicate members, be reordered, added to and edited; as such, they are described as being mutable. In Python, we use square brackets ( [ ] ) when defining a list.

for 3.13 I now better understand procedures and how to develope them. I also now know that a programmer can Create a list of names is an example of a data abstraction that may make it easier for a programmer to manage the complexity of a program, and Place repeated code with procedure calls is an example of a procedural abstraction that may make it easier for a programmer use abstraction to manage the complexity of a program.

for 3.17 I now understand the efficiency of algorithims and how to make them more efficient for example some steps are Analyze and optimize the problem-solving process, Choose the right data structures, Break down complex tasks into smaller ones, Use effective search and sort functions, Explore parallelism, Test and measure performance, and Keep learning and iterating.

for 5.4 I now know more about crowdsurfacing for example Crowdsourcing is the practice of getting a large amount of input or information from people on the Internet. Citizen science is an example of crowdsourcing, but crowdsourcing can also take other forms.

for 1.4 identifying errors, I now understand code better because I am more aware on the positions on where some code should be and why it should be where it is

for 3.5 booleon expressions I now more about booleons for example Boolean expressions are logical statements that evaluate to either true or false, They’re essential in decision-making, programming logic, and controlling flow (e.g., if, while), Control Flow: Used in if, while, and for statements, Logic Building: Helps make decisions in programming (e.g., filters, conditions), Efficiency: Short-circuiting improves performance by skipping unnecessary evaluations, and from now on I will always remember to use parentheses () to make complex expressions clear and avoid ambiguity!

for 4.1 the internet I now understand what Internet Task Force means which is a global community that develops and promotes standards to improve the functionality, security, and growth of the internet. 

for 5.1: Beneficial and Harmful Effects I know understand the purpose of machine learning programs which is To analyze large data sets, recognize patterns, and make predictions based on data, and how cloud computing has impacted internet which is because Cloud computing has helped enhance collaboration, and Cloud computing has introduced new data-security concerns.

for 3.12: Calling Procedures I now understand how to compare the robot algorithms because the robot moves 2 steps forward, rotated right 3 times, then moves forward another 3 spaces for question 21.

Overall, I struggled mainly on the parts that required knowledge for definitions which I have overcame by learning more terms and I will continue to expand my vocabulary for this class, I also struggled in parts that analyzed code so I will try to further analyze and understand the code that I am working on in this class and how the code works for a better understanding of the whole class.

# Sprint 3 big accomplishment 
My biggest and most proudest accomplishment was that since I mainly worked on frontend, I created the overall templete/ outline for how our thing was going to look. The template I created was shared on a google doc called SPrint 3 ideas and led to the creation, formation, and structure of our whole website. Unfortunately the image wont load on vscode so I can show you the doc.

Our project during this Sprint was to build an interactive social media webpage and utilize backend applications to retrieve data that could be used on our social media platform.
Our webpage was centered around book reviews, where users can discuss and interact with reviews of popular books.

Key features:

Like function - one of my biggest accomplishments too which me and nikketh worked on a lot
Rate function
Comment and reply functions
Post function

![alt text]({{site.baseurl}}/images/accomplishment.png) 

This is my biggest accomplishment because me and the Integrater on the team really struggled on getting this working and put a lot of effort into it getting to work. 

the top line of the code Defines a function named toggleLike that will execute whenever it's called (e.g., likely triggered by a click on a "like" button).

The second line of the code Flips the value of the liked variable for example  If liked was true (already liked), this makes it false. If liked was false (not liked), this makes it true.

the third line of code Fetches the HTML element with the ID heart, which is likely where the like icon (e.g., ❤️ or ♡) is displayed.

The fourth line of code changes the appearence of the heart in relation to whether it is liked or not for example it is not likes, it will show ♡ but if it is liked then it will show ❤️

lines 5-8 in the code basically supports the fourth line

The ninth line of code updates the like counter so for example if there is 10 likes and you like it, it will show 11 likes and same for the oppisite way such as if you dislike it

The 10th line of code Updates the entire content of the element with ID likeButton to reflect the new like status and count.

The 11th line of code saves the amount of likes for each book because we have multiple books so if you refresh, it will still appear to be the same

The last line of code Updates the entire content of the element with ID likeButton to reflect the new like status and count, So that the like data persists even if the user refreshes the page or navigates away. It does this by JSON.stringify(likesCount) converts the JavaScript object likesCount into a string, which is required for storage in localStorage.

# purpose of our program
Our program displays a new book every time the page is refreshed.
Users can share their personal experiences with the book by rating it out of five stars, liking the book, commenting on the book, and replying to others' comments. They also have the ability to post about new books they've read by selecting the book reviews group and choosing either the fiction or nonfiction channels.

Key user interactions:

Commenting and liking each other’s posts
Posting in specific channels
The input involves the user’s replies, while the output includes the post count and comment sections.

# summary 
I learned a great deal during this sprint, both on the frontend and backend.
On the frontend, I gained valuable experience in building a visually appealing user interface, focusing on creating intuitive layouts and responsive designs. I learned how to enhance user experience by incorporating interactive elements such as buttons, forms, and dynamic content. I also practiced implementing styles with CSS and JavaScript to make the webpage not only functional but also aesthetically pleasing. On the backend side, I learned how to test backend endpoints using Postman and manipulate data within databases. I also explored how to use JavaScript to fetch and display data dynamically from the backend. Additionally, I learned how to update and edit data on the backend to meet the needs of our project, ensuring seamless communication between the frontend and backend.



